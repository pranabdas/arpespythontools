{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ARPES Python tools The purpose of this module is to provide necessary tools for analyzing ARPES data. Getting started Importing data Image plot k-space conversion Extracting line profile Slicing plane from 3D volume data Rotate map data Crop image Import/export Igor text GitHub project page - https://github.com/pranabdas/arpes-python-tools Dataset used in this tutorial can be downloaded from - http://dx.doi.org/10.17632/rfhhh54g9m Disclaimer: This program is under development. There could be bugs. I hope I will have time to update, bug-fix and add new features regularly, so please check back often. If you find some bugs, or think some features would be helpful, please let me know. You can find contact details in my homepage - https://pranabdas.github.io","title":"Home"},{"location":"#arpes-python-tools","text":"The purpose of this module is to provide necessary tools for analyzing ARPES data. Getting started Importing data Image plot k-space conversion Extracting line profile Slicing plane from 3D volume data Rotate map data Crop image Import/export Igor text GitHub project page - https://github.com/pranabdas/arpes-python-tools Dataset used in this tutorial can be downloaded from - http://dx.doi.org/10.17632/rfhhh54g9m Disclaimer: This program is under development. There could be bugs. I hope I will have time to update, bug-fix and add new features regularly, so please check back often. If you find some bugs, or think some features would be helpful, please let me know. You can find contact details in my homepage - https://pranabdas.github.io","title":"ARPES Python tools"},{"location":"about/","text":"My homepage - https://pranabdas.github.io/","title":"About"},{"location":"crop/","text":"Crop Image (2-Dimensionl data) We can crop images (two-dimensionl data) using crop_2d function. import ARPES_Python_tools as arp # let's import our sample data [data, x, y] = arp.load_ses_spectra('sample_spectrum.txt') import matplotlib.pyplot as plt %matplotlib inline plt.figure(figsize = (8, 6)) plt.imshow(data, origin = 'lower', aspect = 'auto', \\ extent = (y[0], y[-1], x[0], x[-1])) plt.xlabel(\"$\\\\theta$ (deg)\") plt.ylabel('$E_{kin}$ (eV)') plt.set_cmap('magma_r') plt.show() Now, we want to crop and see only the Dirac cone part. We want to crop the energy range (16, 16.8) and angle range (-6, 4). # data_crop, x_crop, y_crop = crop_2d(data, x, y, x_min, x_max, y_min, y_max) data_crop, x_crop, y_crop = arp.crop_2d(data, x, y, 16, 16.8, -6, 4) plt.figure(figsize = (8, 8)) plt.imshow(data_crop, origin = 'lower', aspect = 'auto', \\ extent = (y_crop[0], y_crop[-1], x_crop[0], x_crop[-1])) plt.xlabel(\"$\\\\theta$ (deg)\") plt.ylabel('$E_{kin}$ (eV)') plt.set_cmap('magma_r') plt.show() This is what we wanted.","title":"Crop Image (2D data)"},{"location":"crop/#crop-image-2-dimensionl-data","text":"We can crop images (two-dimensionl data) using crop_2d function. import ARPES_Python_tools as arp # let's import our sample data [data, x, y] = arp.load_ses_spectra('sample_spectrum.txt') import matplotlib.pyplot as plt %matplotlib inline plt.figure(figsize = (8, 6)) plt.imshow(data, origin = 'lower', aspect = 'auto', \\ extent = (y[0], y[-1], x[0], x[-1])) plt.xlabel(\"$\\\\theta$ (deg)\") plt.ylabel('$E_{kin}$ (eV)') plt.set_cmap('magma_r') plt.show() Now, we want to crop and see only the Dirac cone part. We want to crop the energy range (16, 16.8) and angle range (-6, 4). # data_crop, x_crop, y_crop = crop_2d(data, x, y, x_min, x_max, y_min, y_max) data_crop, x_crop, y_crop = arp.crop_2d(data, x, y, 16, 16.8, -6, 4) plt.figure(figsize = (8, 8)) plt.imshow(data_crop, origin = 'lower', aspect = 'auto', \\ extent = (y_crop[0], y_crop[-1], x_crop[0], x_crop[-1])) plt.xlabel(\"$\\\\theta$ (deg)\") plt.ylabel('$E_{kin}$ (eV)') plt.set_cmap('magma_r') plt.show() This is what we wanted.","title":"Crop Image (2-Dimensionl data)"},{"location":"data_import/","text":"Importing ARPES data At the moment, this module can only import data produced by Scienta-Omicron SES program. For the Spectral scans, we will use the plaintext (.txt) files as input, and in case of Fermi map data, we will need the ZIP files as input. First thing first, import ARPES_Python_tools in your program import ARPES_Python_tools as arp Load ARPES Spectra from SES plaintext file [data, energy, angle] = arp.load_ses_spectra('sample_spectra.txt') Here, data is a two dimensional numpy array; x-dimension is along energy and y-dimension is along angle/theta. energy and angle are one dimensional vectors of kinetic energy in eV and angle values in degree, respectively. Load Fermi Map data from SES ZIP file [map_data, energy, theta, phi] = arp.load_ses_map('sample_map_data.zip') map_data will contain three dimensional array of Fermi map data; x-dimension is along energy, y-dimension is along theta and z-dimension is along phi. energy , theta , and phi are one dimensional vectors of kinetic energy (eV), theta (deg), and phi (deg), respectively. Notice that you do not need to unzip the SES produced ZIP file, the program directly reads from ZIP data.","title":"Importing Data"},{"location":"data_import/#importing-arpes-data","text":"At the moment, this module can only import data produced by Scienta-Omicron SES program. For the Spectral scans, we will use the plaintext (.txt) files as input, and in case of Fermi map data, we will need the ZIP files as input. First thing first, import ARPES_Python_tools in your program import ARPES_Python_tools as arp","title":"Importing ARPES data"},{"location":"data_import/#load-arpes-spectra-from-ses-plaintext-file","text":"[data, energy, angle] = arp.load_ses_spectra('sample_spectra.txt') Here, data is a two dimensional numpy array; x-dimension is along energy and y-dimension is along angle/theta. energy and angle are one dimensional vectors of kinetic energy in eV and angle values in degree, respectively.","title":"Load ARPES Spectra from SES plaintext file"},{"location":"data_import/#load-fermi-map-data-from-ses-zip-file","text":"[map_data, energy, theta, phi] = arp.load_ses_map('sample_map_data.zip') map_data will contain three dimensional array of Fermi map data; x-dimension is along energy, y-dimension is along theta and z-dimension is along phi. energy , theta , and phi are one dimensional vectors of kinetic energy (eV), theta (deg), and phi (deg), respectively. Notice that you do not need to unzip the SES produced ZIP file, the program directly reads from ZIP data.","title":"Load Fermi Map data from SES ZIP file"},{"location":"gs/","text":"Getting started with ARPES Python tools Requirements: You will need Python 3 , and following Python packages installed in your computer: numpy matplotlib scipy Installation of ARPES Python tools: You can download/install the module from GitHub - https://github.com/thepranab/arpes_python_tools Importing ARPES Python tools in your programs: You can import the module by import ARPES_Python_tools as arp so that later in the code you can refer to the module as arp in short. Sample data used in this tutorial: You can find the sample data set used in this tutorial here - http://dx.doi.org/10.17632/rfhhh54g9m","title":"Getting Started"},{"location":"gs/#getting-started-with-arpes-python-tools","text":"Requirements: You will need Python 3 , and following Python packages installed in your computer: numpy matplotlib scipy Installation of ARPES Python tools: You can download/install the module from GitHub - https://github.com/thepranab/arpes_python_tools Importing ARPES Python tools in your programs: You can import the module by import ARPES_Python_tools as arp so that later in the code you can refer to the module as arp in short. Sample data used in this tutorial: You can find the sample data set used in this tutorial here - http://dx.doi.org/10.17632/rfhhh54g9m","title":"Getting started with ARPES Python tools"},{"location":"igor_text/","text":"Import/Export Igor Text (.itx format) If you need to work with Igor Program, ARPES Python Tools provides a way to import and export data in Igor text ( .itx ) format. import_itx and export_itx functions can import and export 1-dimensionl, 2-dimensionl, and 3-dimensionl data, respectively. import ARPES_Python_tools as arp # import itx file data, x = arp.import_itx('path/data.itx') # 1D wave data, x, y = arp.import_itx('path/data.itx') # 2D wave data, x, y, z = arp.import_itx('path/data.itx') # 3D wave # export itx file export_itx(\"path/data.itx\", data, x=[], y=[], z =[], wave_name='wave',\\ x_label='x-label', y_label='y-label', z_label='z-label') While importing, data contains the 1D, 2D or 3D data. x, y, z are the corresponding axis scaling. While exporting, if you do not have axis scaling data, you do not need to provide x, y, or z. In case x, y, z is not provided the default scaling (dim offset = 0, and dim delta = 1) would be applied. Similarly, you can provide wave name, and axis labels (optional).","title":"Import/Export Igor text"},{"location":"igor_text/#importexport-igor-text-itx-format","text":"If you need to work with Igor Program, ARPES Python Tools provides a way to import and export data in Igor text ( .itx ) format. import_itx and export_itx functions can import and export 1-dimensionl, 2-dimensionl, and 3-dimensionl data, respectively. import ARPES_Python_tools as arp # import itx file data, x = arp.import_itx('path/data.itx') # 1D wave data, x, y = arp.import_itx('path/data.itx') # 2D wave data, x, y, z = arp.import_itx('path/data.itx') # 3D wave # export itx file export_itx(\"path/data.itx\", data, x=[], y=[], z =[], wave_name='wave',\\ x_label='x-label', y_label='y-label', z_label='z-label') While importing, data contains the 1D, 2D or 3D data. x, y, z are the corresponding axis scaling. While exporting, if you do not have axis scaling data, you do not need to provide x, y, or z. In case x, y, z is not provided the default scaling (dim offset = 0, and dim delta = 1) would be applied. Similarly, you can provide wave name, and axis labels (optional).","title":"Import/Export Igor Text (.itx format)"},{"location":"image_plot/","text":"Image Plot This example provides basic example of image plot using matplotlib . There is a huge list of customization possible using matplotlib . You can read matplotlib documentation : https://matplotlib.org/ for advanced customization. import ARPES_Python_tools as arp [data, energy, angle] = arp.load_ses_spectra('sample_spectra.txt') # Plot image import matplotlib.pyplot as plt %matplotlib inline # Above line is specific to Jupyter Notebook plt.figure(figsize = (8, 6)) plt.imshow(data, origin = 'lower', aspect = 'auto', \\ extent = (angle[0], angle[-1], energy[0], energy[-1])) plt.xlabel(\"$\\\\theta$ (deg)\") plt.ylabel('$E_{kin}$ (eV)') plt.set_cmap('magma_r') plt.show() You should see a plot like this upon successful execution:","title":"Image Plot"},{"location":"image_plot/#image-plot","text":"This example provides basic example of image plot using matplotlib . There is a huge list of customization possible using matplotlib . You can read matplotlib documentation : https://matplotlib.org/ for advanced customization. import ARPES_Python_tools as arp [data, energy, angle] = arp.load_ses_spectra('sample_spectra.txt') # Plot image import matplotlib.pyplot as plt %matplotlib inline # Above line is specific to Jupyter Notebook plt.figure(figsize = (8, 6)) plt.imshow(data, origin = 'lower', aspect = 'auto', \\ extent = (angle[0], angle[-1], energy[0], energy[-1])) plt.xlabel(\"$\\\\theta$ (deg)\") plt.ylabel('$E_{kin}$ (eV)') plt.set_cmap('magma_r') plt.show() You should see a plot like this upon successful execution:","title":"Image Plot"},{"location":"k_conv/","text":"k-space conversion for single spectra The k_conv function can convert two-dimensional Energy vs Theta data to Binding energy vs k (momentum). Here Binding energy below the Fermi energy is positive convention used. import ARPES_Python_tools as arp [data, energy, angle] = arp.load_ses_spectra('sample_spectra.txt') [data_k, e_bin, k] = arp.k_conv(data, energy, angle, 16.67) # Fermi energy = 16.67 eV # Plot image import matplotlib.pyplot as plt %matplotlib inline # Above line is specific to Jupyter Notebook plt.figure(figsize = (8, 6)) plt.imshow(data_k, origin = 'lower', aspect = 'auto', \\ extent = (k[0], k[-1], e_bin[0], e_bin[-1])) plt.xlabel(\"k ($\\AA^{-1}$)\") plt.ylabel('$E_{bin}$ (eV)') plt.set_cmap('magma_r') plt.show() Which would produce a plot like this: k-space conversion for 3D Fermi map data Similarly, we can convert three dimensional (Energy, theta, phi) Fermi map data to k -space by using k_conv3D function. [data, energy, theta, phi] = arp.load_ses_map('sample_map_data.zip') [data_k, e_bin, kx, ky] = arp.k_conv3D(data, energy, theta, phi, 16.67) # Fermi energy = 16.67 eV Depending on the size of data and computing power, the program might take few minutes to complete the calculations.","title":"k-space Conversion"},{"location":"k_conv/#k-space-conversion-for-single-spectra","text":"The k_conv function can convert two-dimensional Energy vs Theta data to Binding energy vs k (momentum). Here Binding energy below the Fermi energy is positive convention used. import ARPES_Python_tools as arp [data, energy, angle] = arp.load_ses_spectra('sample_spectra.txt') [data_k, e_bin, k] = arp.k_conv(data, energy, angle, 16.67) # Fermi energy = 16.67 eV # Plot image import matplotlib.pyplot as plt %matplotlib inline # Above line is specific to Jupyter Notebook plt.figure(figsize = (8, 6)) plt.imshow(data_k, origin = 'lower', aspect = 'auto', \\ extent = (k[0], k[-1], e_bin[0], e_bin[-1])) plt.xlabel(\"k ($\\AA^{-1}$)\") plt.ylabel('$E_{bin}$ (eV)') plt.set_cmap('magma_r') plt.show() Which would produce a plot like this:","title":"k-space conversion for single spectra"},{"location":"k_conv/#k-space-conversion-for-3d-fermi-map-data","text":"Similarly, we can convert three dimensional (Energy, theta, phi) Fermi map data to k -space by using k_conv3D function. [data, energy, theta, phi] = arp.load_ses_map('sample_map_data.zip') [data_k, e_bin, kx, ky] = arp.k_conv3D(data, energy, theta, phi, 16.67) # Fermi energy = 16.67 eV Depending on the size of data and computing power, the program might take few minutes to complete the calculations.","title":"k-space conversion for 3D Fermi map data"},{"location":"line_profile/","text":"Extracting line profile How can we extract line profile from our two-dimensional image data? The function line_profile does the work. Let's say we want to extract an energy distribution curve from our ARPES spectrum. import ARPES_Python_tools as arp [data, energy, angle] = arp.load_ses_spectra('sample_spectra.txt') # We want to extract line profile between angles (-3, 3) edc = arp.line_profile(data, energy, angle, -3, 3) # Plot image import matplotlib.pyplot as plt %matplotlib inline # Above line is specific to Jupyter Notebook plt.figure(figsize = (8, 6)) plt.plot(energy, edc) plt.xlabel('$E_{kin}$ (eV)') plt.ylabel('Intensity (a.u)') plt.show() How about if we want the momentum distribution curve instead? That means we have to extract line profile along the other axis, which can be done by transposing the data, and interchanging the axes: # We want to extract line profile between energy values (16.5, 16.7) mdc = arp.line_profile(data.T, angle, energy, 16.5, 16.7) # Plot image import matplotlib.pyplot as plt %matplotlib inline # Above line is specific to Jupyter Notebook plt.figure(figsize = (8, 6)) plt.plot(angle, mdc) plt.xlabel('$\\\\theta$ (deg)') plt.ylabel('Intensity (a.u)') plt.show()","title":"Extracting Line Profile"},{"location":"line_profile/#extracting-line-profile","text":"How can we extract line profile from our two-dimensional image data? The function line_profile does the work. Let's say we want to extract an energy distribution curve from our ARPES spectrum. import ARPES_Python_tools as arp [data, energy, angle] = arp.load_ses_spectra('sample_spectra.txt') # We want to extract line profile between angles (-3, 3) edc = arp.line_profile(data, energy, angle, -3, 3) # Plot image import matplotlib.pyplot as plt %matplotlib inline # Above line is specific to Jupyter Notebook plt.figure(figsize = (8, 6)) plt.plot(energy, edc) plt.xlabel('$E_{kin}$ (eV)') plt.ylabel('Intensity (a.u)') plt.show() How about if we want the momentum distribution curve instead? That means we have to extract line profile along the other axis, which can be done by transposing the data, and interchanging the axes: # We want to extract line profile between energy values (16.5, 16.7) mdc = arp.line_profile(data.T, angle, energy, 16.5, 16.7) # Plot image import matplotlib.pyplot as plt %matplotlib inline # Above line is specific to Jupyter Notebook plt.figure(figsize = (8, 6)) plt.plot(angle, mdc) plt.xlabel('$\\\\theta$ (deg)') plt.ylabel('Intensity (a.u)') plt.show()","title":"Extracting line profile"},{"location":"plane_slice/","text":"Slicing planes from 3D volume data We can slice our 3D Fermi map data in order to get a particular plane using plane_slice function. Say, we need a constant energy cut. import ARPES_Python_tools as arp [data, energy, angle] = arp.load_ses_spectra('sample_spectra.txt') # We want the iso-energy surface integrated between the energy values 15.6 and 15.8 eV iso_energy_surf = arp.plane_slice(data, energy, 15.6, 15.8) # Plot image import matplotlib.pyplot as plt %matplotlib inline # Above line is specific to Jupyter Notebook plt.figure(figsize = (8, 6)) plt.imshow(iso_energy_surf, origin = 'lower', aspect = 'auto', \\ extent = (theta[0], theta[-1], phi[0], phi[-1])) plt.xlabel('$\\\\phi$ (deg)') plt.ylabel(\"$\\\\theta$ (deg)\") plt.show() This should give you an iso-energy surface like this: How about if we want the slice along another axis? All we need is transpose the data, and provide the correct axis input. # We want a cut integrating phi values between (-0.5, 0.5) degrees phi_slice = arp.plane_slice(data.transpose([2, 0, 1]), phi, -0.5, 0.5) # Plot image import matplotlib.pyplot as plt %matplotlib inline # Above line is specific to Jupyter Notebook plt.figure(figsize = (8, 6)) plt.imshow(phi_slice, origin = 'lower', aspect = 'auto', \\ extent = (phi[0], phi[-1], energy[0], energy[-1])) plt.xlabel(\"$\\\\theta$ (deg)\") plt.ylabel('$E_{kin}$ (eV)') plt.show()","title":"Slicing plane"},{"location":"plane_slice/#slicing-planes-from-3d-volume-data","text":"We can slice our 3D Fermi map data in order to get a particular plane using plane_slice function. Say, we need a constant energy cut. import ARPES_Python_tools as arp [data, energy, angle] = arp.load_ses_spectra('sample_spectra.txt') # We want the iso-energy surface integrated between the energy values 15.6 and 15.8 eV iso_energy_surf = arp.plane_slice(data, energy, 15.6, 15.8) # Plot image import matplotlib.pyplot as plt %matplotlib inline # Above line is specific to Jupyter Notebook plt.figure(figsize = (8, 6)) plt.imshow(iso_energy_surf, origin = 'lower', aspect = 'auto', \\ extent = (theta[0], theta[-1], phi[0], phi[-1])) plt.xlabel('$\\\\phi$ (deg)') plt.ylabel(\"$\\\\theta$ (deg)\") plt.show() This should give you an iso-energy surface like this: How about if we want the slice along another axis? All we need is transpose the data, and provide the correct axis input. # We want a cut integrating phi values between (-0.5, 0.5) degrees phi_slice = arp.plane_slice(data.transpose([2, 0, 1]), phi, -0.5, 0.5) # Plot image import matplotlib.pyplot as plt %matplotlib inline # Above line is specific to Jupyter Notebook plt.figure(figsize = (8, 6)) plt.imshow(phi_slice, origin = 'lower', aspect = 'auto', \\ extent = (phi[0], phi[-1], energy[0], energy[-1])) plt.xlabel(\"$\\\\theta$ (deg)\") plt.ylabel('$E_{kin}$ (eV)') plt.show()","title":"Slicing planes from 3D volume data"},{"location":"rotate/","text":"Rotate Fermi map data If your Fermi map measurement was not done keeping the high symmetry directions along the slit direction (or perpendicular to the slit direction), and you need to rotate the collected data in order to make the high symmetry directions along the x- or y-coordinate, the rotate function comes handy. This function needs the map data (3-dimensional array with first dimension along the energy, second and third dimensions are kx and ky, respectively.). It also needs kx and ky vectors as input. Provide the required angle to rotate in degree. The function returns rotated data, and new KX and KY vectors. Let's see an example: import ARPES_Python_tools as arp import matplotlib.pyplot as plt %matplotlib inline # Let's import our sample map data [data, energy, theta, phi] = arp.load_ses_map('sample_map_data.zip') # Plot one slice plt.figure(figsize = (8, 6)) plt.imshow(data[150, :, :], origin = 'lower', aspect = 'auto',\\ extent = (phi[0], phi[-1], theta[0], theta[-1])) plt.show() This is how a constant energy cut looks like before rotation: Now, we can rotate the data. Note that rotating involves some heavy interpolation. So, this might take several tens of minutes to complete depending on the data size. data_r, theta_r, phi_r = arp.rotate(data, 45, theta, phi) # Plot one slice plt.figure(figsize = (8, 6)) plt.imshow(data_r[150, :, :], origin = 'lower', aspect = 'auto',\\ extent = (phi_r[0], phi_r[-1], theta_r[0], theta_r[-1])) plt.show() Let us plot a slice again. This is what we get after the rotation.","title":"Rotate map data"},{"location":"rotate/#rotate-fermi-map-data","text":"If your Fermi map measurement was not done keeping the high symmetry directions along the slit direction (or perpendicular to the slit direction), and you need to rotate the collected data in order to make the high symmetry directions along the x- or y-coordinate, the rotate function comes handy. This function needs the map data (3-dimensional array with first dimension along the energy, second and third dimensions are kx and ky, respectively.). It also needs kx and ky vectors as input. Provide the required angle to rotate in degree. The function returns rotated data, and new KX and KY vectors. Let's see an example: import ARPES_Python_tools as arp import matplotlib.pyplot as plt %matplotlib inline # Let's import our sample map data [data, energy, theta, phi] = arp.load_ses_map('sample_map_data.zip') # Plot one slice plt.figure(figsize = (8, 6)) plt.imshow(data[150, :, :], origin = 'lower', aspect = 'auto',\\ extent = (phi[0], phi[-1], theta[0], theta[-1])) plt.show() This is how a constant energy cut looks like before rotation: Now, we can rotate the data. Note that rotating involves some heavy interpolation. So, this might take several tens of minutes to complete depending on the data size. data_r, theta_r, phi_r = arp.rotate(data, 45, theta, phi) # Plot one slice plt.figure(figsize = (8, 6)) plt.imshow(data_r[150, :, :], origin = 'lower', aspect = 'auto',\\ extent = (phi_r[0], phi_r[-1], theta_r[0], theta_r[-1])) plt.show() Let us plot a slice again. This is what we get after the rotation.","title":"Rotate Fermi map data"}]}